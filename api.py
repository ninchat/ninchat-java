#!/usr/bin/env python

import cStringIO as stringio
import os
import sys

sys.path.insert(0, "ninchat-python")

import ninchat.api

javatypes = {
	"bool":         "Boolean",
	"float":        "Double",
	"int":          "Long",
	"object":       "JsonObject",
	"string":       "String",
	"string array": "String[]",
	"time":         "Integer",
}

javareserved = {
	"abstract", "assert", "boolean", "break", "byte", "case", "catch", "char",
	"class", "const", "continue", "default", "do", "double", "else", "enum",
	"extends", "false", "final", "finally", "float", "for", "goto", "if",
	"implements", "import", "instanceof", "int", "interface", "long", "native",
	"new", "null", "package", "private", "protected", "public", "return",
	"short", "static", "strictfp", "super", "switch", "synchronized", "this",
	"throw", "throws", "transient", "true", "try", "void", "volatile", "while",
}

actionbases = {
	"send_message": "PayloadAction",
}

eventbases = {
	"message_received": "PayloadEvent",
}

attrclasses = {
	"UserAttrs":           ninchat.api.attrs.user,
	"IdentityAttrs":       ninchat.api.attrs.identity,
	"DialogueMemberAttrs": ninchat.api.attrs.dialoguemember,
	"ChannelAttrs":        ninchat.api.attrs.channel,
	"ChannelMemberAttrs":  ninchat.api.attrs.channelmember,
	"RealmAttrs":          ninchat.api.attrs.realm,
	"RealmMemberAttrs":    ninchat.api.attrs.realmmember,
}

class Output(object):

	def __init__(self, package, name):
		dirname = os.path.join("ninchat-java", "gen", "com", "ninchat", "client", "transport", package)
		if not os.path.exists(dirname):
			os.makedirs(dirname)

		self.filename = os.path.join(dirname, name + ".java")

	def __enter__(self):
		self.buffer = stringio.StringIO()

		self.orig_stdout = sys.stdout
		sys.stdout = self.buffer

	def __exit__(self, exc_type, exc_value, traceback):
		assert sys.stdout is self.buffer
		sys.stdout = self.orig_stdout

		if not exc_type:
			with open(self.filename, "w") as file:
				file.write(self.buffer.getvalue())

def main():
	with Output("", "EventClassRegistry"):
		print_event_registry(ninchat.api.events)

	for action in ninchat.api.actions.values():
		with Output("actions", title(action.name)):
			print_action(action)

	for event in ninchat.api.events.values():
		with Output("events", title(event.name)):
			print_event(event)

	for classname, attrs in attrclasses.items():
		with Output("attributes", classname):
			print_attrclass(classname, attrs)

def print_header():
	print "//"
	print "// THIS FILE IS AUTO GENERATED BY api.py - DO NOT EDIT BY HAND!"
	print "// Definitions can be found at: https://github.com/ninchat/ninchat-api/tree/master/json"
	print "//"
	print

def print_event_registry(events):
	print_header()
	print "package com.ninchat.client.transport;"
	print
	print "import com.ninchat.client.transport.events.*;"
	print "import com.ninchat.client.transport.events.Error;"
	print
	print "import java.util.Collections;"
	print "import java.util.HashMap;"
	print "import java.util.Map;"
	print
	print "public class EventClassRegistry {"
	print "\tstatic final Map<String, Class<? extends Event>> eventClasses;"
	print "\tstatic {"
	print "\t\tMap<String, Class<? extends Event>> e = new HashMap<String, Class<? extends Event>>();"

	for event in events.values():
		print "\t\te.put(\"{}\", {}.class);".format(event.name, title(event.name))

	print "\t\teventClasses = Collections.unmodifiableMap(e);"
	print "\t}"
	print "}"

def print_action(action):
	print_header()
	print "package com.ninchat.client.transport.actions;"
	print
	print "import com.google.gson.annotations.SerializedName;"
	print
	print "import com.ninchat.client.transport.*;"
	print "import com.ninchat.client.transport.attributes.*;"
	print "import com.ninchat.client.transport.parameters.*;"
	print
	print "public class {} extends {}".format(title(action.name), actionbases.get(action.name, "Action"))
	print "{"
	print_params(action.params)
	print
	print "\t@Override"
	print "\tpublic String getActionName()"
	print "\t{"
	print '\t\treturn "{}";'.format(action.name)
	print "\t}"
	print_action_id(action.params.get("action_id"))
	print "}"

def print_event(event):
	print_header()
	print "package com.ninchat.client.transport.events;"
	print
	print "import com.google.gson.annotations.SerializedName;"
	print
	print "import com.ninchat.client.transport.*;"
	print "import com.ninchat.client.transport.attributes.*;"
	print "import com.ninchat.client.transport.parameters.*;"
	print
	print "public class {} extends {}".format(title(event.name), eventbases.get(event.name, "Event"))
	print "{"

	if "_member_" in event.name:
		membertype, _, _ = event.name.split("_")
	else:
		membertype = None

	print_params(event.params, membertype)

	print
	print "\t@Override"
	print "\tpublic String getEventName()"
	print "\t{"
	print '\t\treturn "{}";'.format(event.name)
	print "\t}"
	print "}"

def print_attrclass(name, attrs):
	print_header()
	print "package com.ninchat.client.transport.attributes;"
	print
	print "import com.google.gson.JsonObject;"
	print "import com.google.gson.annotations.SerializedName;"
	print
	print "public class {}".format(name)
	print "{"
	print_properties([a for _, a in sorted(attrs.iteritems())], attrtypeof)
	print "}"

def print_params(params, membertype=None):
	paramlist = [p for _, p in sorted(params.iteritems()) if p.name != "action_id"]
	print_properties(paramlist, paramtypeof, membertype)

	print
	print "\t@Override"
	print "\tpublic boolean verify()"
	print "\t{"
	print "\t\treturn {};".format(" &&\n\t\t       ".join("{} != null".format(camel(p.name)) for p in paramlist if p.required) or "true")
	print "\t}"

def print_properties(propertylist, typeof, membertype=None):
	"""Print parameters or attributes."""

	for p in propertylist:
		var = typeof(p)
		sig = [var]

		if p.name == "member_attrs":
			if membertype:
				var = title(membertype) + title(p.name)
				sig = [var]
			else:
				var = "Object"
				sig = [x + title(p.name) for x in ("Channel", "Realm")]

		print '\t@SerializedName("{}")'.format(p.name)
		print "\tprivate {} {} = {};".format(var, camel(p.name), "null")
		print

		if len(sig) == 1:
			print "\tpublic {} get{}()".format(sig[0], title(p.name))
			print "\t{"

			if sig[0] == "Boolean":
				print "\t\treturn {} == null ? false : {};".format(camel(p.name), camel(p.name))
			else:
				print "\t\treturn {};".format(camel(p.name))

			print "\t}"
			print

		for t in sig:
			print "\tpublic void set{}({} {})".format(title(p.name), t, camel(p.name))
			print "\t{"
			print "\t\tthis.{0} = {0};".format(camel(p.name))
			print "\t}"
			print

def print_action_id(param):
	if param:
		if param.required:
			print
			print "\t@Override"
			print "\tpublic boolean isExpectActionId()"
			print "\t{"
			print "\t\treturn true;"
			print "\t}"
		else:
			print
			print "\tprivate transient boolean expectActionId = true;"
			print
			print "\t@Override"
			print "\tpublic boolean isExpectActionId()"
			print "\t{"
			print "\t\treturn expectActionId;"
			print "\t}"
			print
			print "\tpublic void setExpectActionId(boolean expectActionId)"
			print "\t{"
			print "\t\tthis.expectActionId = expectActionId;"
			print "\t}"
	else:
		print
		print "\t@Override"
		print "\tpublic boolean isExpectActionId()"
		print "\t{"
		print "\t\treturn false;"
		print "\t}"

def attrtypeof(attr):
	return javatypes[attr.type]

def paramtypeof(param):
	if param.type == "object":
		return title(param.name)
	else:
		return javatypes[param.type]

def title(s):
	return s.title().replace("_", "")

def camel(s):
	s = s[0] + title(s)[1:]
	if s in javareserved:
		s = "_" + s
	return s

if __name__ == "__main__":
	main()
